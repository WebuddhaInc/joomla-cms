<?php

/**
 *
 * Folder extraction class
 *
 * It was faster to hack this then refactor the base restore operation to
 * recognize a folder.
 *
 */

class AKUnarchiverFolder extends AKUnarchiverJPA
{

  var $expectDataDescriptor = false;

  /**
   * [readArchiveHeader description]
   * @return [type] [description]
   */
  protected function readArchiveHeader()
  {

    // Prepare
      $this->currentPartOffset = 0;
      $this->dataReadLength    = 0;

    // Yuup..
      return true;

  }

  /**
   * [readFileHeader description]
   * @return [type] [description]
   */
  protected function readFileHeader()
  {

    inspect('readFileHeader');  die(__LINE__.': '.__FILE__);

    // Move to Next
      if( empty($this->fp) || $this->isEOF(true) ) {
        $this->nextFile();
      }

    // Start fileHeader block
      $this->fileHeader = new stdClass();
      $this->fileHeader->timestamp = 0;

    // Identify Filename
      $root = AKFactory::get('kickstart.setup.destdir');
      $file = $this->fileList[ $this->currentPartNumber ];
      $this->fileHeader->file         = $root . $file;
      $this->fileHeader->sourceFile   = $this->getFilename() . DS . $file;
      $this->fileHeader->compressed   = filesize( $this->fileHeader->sourceFile );
      $this->fileHeader->uncompressed = 0;
      $this->fileHeader->compression  = 'none';
      $this->fileHeader->type         = 'file';
      $this->fileHeader->permissions  = '0644';

    // Find hard-coded banned files
      if( (basename($this->fileHeader->file) == ".") || (basename($this->fileHeader->file) == "..") ){
        $isBannedFile = true;
      }

    // Also try to find banned files passed in class configuration
      if((count($this->skipFiles) > 0) && (!$isRenamed) ){
        if(in_array($this->fileHeader->file, $this->skipFiles)){
          $isBannedFile = true;
        }
      }

    // Handle file renaming
      $isRenamed = false;
      if(is_array($this->renameFiles) && (count($this->renameFiles) > 0) ){
        if(array_key_exists($this->fileHeader->file, $this->renameFiles)){
          $this->fileHeader->file = $this->renameFiles[$this->fileHeader->file];
          $isRenamed = true;
        }
      }

    // Handle directory renaming
      $isDirRenamed = false;
      if(is_array($this->renameDirs) && (count($this->renameDirs) > 0)) {
        if(array_key_exists(dirname($this->fileHeader->file), $this->renameDirs)) {
          $this->fileHeader->file = rtrim($this->renameDirs[dirname($this->fileHeader->file)],'/').'/'.basename($this->fileHeader->file);
          $isRenamed = true;
          $isDirRenamed = true;
        }
      }

    // Find hard-coded banned files
      if( (basename($this->fileHeader->file) == ".") || (basename($this->fileHeader->file) == "..") ){
        $isBannedFile = true;
      }

    // Also try to find banned files passed in class configuration
      if((count($this->skipFiles) > 0) && (!$isRenamed) ){
        if(in_array($this->fileHeader->file, $this->skipFiles)){
          $isBannedFile = true;
        }
      }

    // Get the translated path name
      $restorePerms = AKFactory::get('kickstart.setup.restoreperms', false);
      if($restorePerms){
        $this->fileHeader->realFile = $this->postProcEngine->processFilename( $this->fileHeader->file, $this->fileHeader->permissions );
      }
      else {
        $this->fileHeader->realFile = $this->postProcEngine->processFilename( $this->fileHeader->file );
      }

    // Prepare Destination
      $this->createDirectory();

    // Header is read
      $this->runState = AK_STATE_HEADER;

    // Read for File Copy
      $this->dataReadLength = 0;

    // Go
      return true;

  }

  protected function _run(){

    if($this->getState() == 'postrun') return;
    $this->setState('running');
    $timer = AKFactory::getTimer();
    $status = true;

    while( $status && ($timer->getTimeLeft() > 0) ){
      switch( $this->runState ){
        case AK_STATE_NOFILE:
          // Queue
            $this->nextFile();
          // Send start of file notification
            $message = new stdClass;
            $message->type = 'startfile';
            $message->content = new stdClass;
            $message->content->compressed   = $this->totalSize;
            $message->content->uncompressed = 0;
            $this->notify($message);
          break;
        case AK_STATE_HEADER:
        case AK_STATE_DATA:
          $status = $this->processFileData();
          break;
        case AK_STATE_DATAREAD:
        case AK_STATE_POSTPROC:
          die(__LINE__.': '.__FILE__);
          break;
        case AK_STATE_DONE:
        default:
          die(__LINE__.': '.__FILE__);
          break;
      }
    }

  }

  /**
   * Opens the next part file for reading
   */
  protected function nextFile(){
    debugMsg('Current part is ' . $this->currentPartNumber . '; opening the next part');
    ++$this->currentPartNumber;
    if($this->currentPartNumber > (count($this->fileList) - 1)){
      $this->setState('postrun');
      return false;
    }
    if(is_resource($this->fp)){
      @fclose($this->fp);
    }
    debugMsg('Opening file ' . $this->fileList[$this->currentPartNumber]);
    $this->fp = @fopen($this->fileList[$this->currentPartNumber], 'rb');
    if($this->fp === false){
      debugMsg('Could not open file - crash imminent');
    }
    fseek($this->fp, 0);
    $this->currentPartOffset = 0;
    return true;
  }

  /**
   * [processFileData description]
   * @return [type] [description]
   */
  protected function processFileData(){

    $this->state = AK_STATE_DONE;
    return true;

    // Uncompressed files are being processed in small chunks, to avoid timeouts
      if( ($this->dataReadLength == 0) && !AKFactory::get('kickstart.setup.dryrun','0') ){
        // Before processing file data, ensure permissions are adequate
        $this->setCorrectPermissions( $this->fileHeader->file );
      }

    // Open the output file
      if( !AKFactory::get('kickstart.setup.dryrun','0') ){
        $ignore = AKFactory::get('kickstart.setup.ignoreerrors', false) || $this->isIgnoredDirectory($this->fileHeader->file);
        if ($this->dataReadLength == 0) {
          $outfp = @fopen( $this->fileHeader->realFile, 'wb' );
        } else {
          $outfp = @fopen( $this->fileHeader->realFile, 'ab' );
        }
        // Can we write to the file?
        if( ($outfp === false) && (!$ignore) ) {
          // An error occured
          debugMsg('Could not write to output file');
          $this->setError( AKText::sprintf('COULDNT_WRITE_FILE', $this->fileHeader->realFile) );
          return false;
        }
      }

    // Does the file have any data, at all?
      if( $this->fileHeader->compressed == 0 ){
        // No file data!
        if( !AKFactory::get('kickstart.setup.dryrun','0') && is_resource($outfp) ) @fclose($outfp);
        $this->runState = AK_STATE_DATAREAD;
        return true;
      }

    // Reference to the global timer
      $timer = AKFactory::getTimer();
      $toReadBytes = 0;
      $leftBytes = $this->fileHeader->compressed - $this->dataReadLength;

    // Loop while there's data to read and enough time to do it

      inspect( $this, $this->fp, is_resource($this->fp)?1:0 );
      die(__LINE__.': '.__FILE__);
      while(
        !$this->isEOF(true)
        &&
        ($leftBytes > 0) && ($timer->getTimeLeft() > 0)
        ){
        $toReadBytes = ($leftBytes > $this->chunkSize) ? $this->chunkSize : $leftBytes;
        $data = $this->fread( $this->fp, $toReadBytes );
        $reallyReadBytes = akstringlen($data);
        $leftBytes -= $reallyReadBytes;
        $this->dataReadLength += $reallyReadBytes;
        if( !AKFactory::get('kickstart.setup.dryrun','0') )
          if(is_resource($outfp)) @fwrite( $outfp, $data );
      }

    // Close the file pointer
      if( !AKFactory::get('kickstart.setup.dryrun','0') )
        if(is_resource($outfp)) @fclose($outfp);

    // Was this a pre-timeout bail out?
      if( $leftBytes > 0 )
      {
        $this->runState = AK_STATE_DATA;
      }
      else
      {
        // Oh! We just finished!
        $this->runState = AK_STATE_DATAREAD;
        $this->dataReadLength = 0;
      }

    return true;

  }


  /**
   * Scans for archive parts
   */
  protected function scanArchives()
  {

    // Reset
      $this->currentPartNumber = -1;
      $this->currentPartOffset = 0;
      $this->runState          = AK_STATE_NOFILE;
      $this->totalSize         = 0;
      $this->fileList          = array();

    // Scan Package
      $this->__scanFolderRecursively( $this->getFilename() );

    // Send start of file notification
      $message = new stdClass;
      $message->type = 'totalsize';
      $message->content = new stdClass;
      $message->content->totalsize = $this->totalSize;
      $message->content->filelist = array($this->getFilename());
      $this->notify($message);

  }

  /**
   * [__scanRecursively description]
   * @param  [type] $path [description]
   * @return [type]       [description]
   */
  protected function __scanFolderRecursively( $base, $path=null ){
    $files = scandir( $base.DS.$path );
    foreach( $files AS $file ){
      if( !preg_match('/^\.+$/', $file) ){
        if( is_dir($base.DS.$path.$file) ){
          $this->__scanFolderRecursively($base, $path.$file.DS);
        }
        else if( is_readable($base.DS.$path.$file) ){
          $this->totalSize += filesize($base.DS.$path.$file);
          $this->fileList[] = $path . $file;
        }
      }
    }
  }

}

